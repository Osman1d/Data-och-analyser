import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.sparse import csc_matrix
from sklearn.neighbors import NearestNeighbors
import os

# Skapa mapp för visualiseringar
output_dir = "visualiseringar"
os.makedirs(output_dir, exist_ok=True)

# --- 1.1 Movielens full - EDA ---

# Läsa in data från movies.csv och ratings.csv
movies = pd.read_csv("movies.csv")
ratings = pd.read_csv("ratings.csv")

# Kombinera dataseten för enklare analys
movie_ratings = pd.merge(ratings, movies, on="movieId")

# a) EDA - Grundläggande undersökning av datasetet
print("### EDA - Grundläggande information")
print(f"Antal filmer: {movies['movieId'].nunique()}")
print(f"Antal ratings: {ratings.shape[0]}")
print(f"Antal användare: {ratings['userId'].nunique()}")

# Fördelning av ratings
plt.figure(figsize=(8, 6))
sns.histplot(ratings["rating"], bins=10, color="skyblue")
plt.title("Fördelning av betyg", fontsize=14)
plt.xlabel("Betyg", fontsize=12)
plt.ylabel("Antal", fontsize=12)
plt.savefig(os.path.join(output_dir, "rating_distribution.png"), facecolor="white", bbox_inches="tight")
plt.close()

# b) Top 10 filmer med flest ratings
top_10_rated = movie_ratings.groupby("title").size().sort_values(ascending=False).head(10)
print("\n### b) Top 10 filmer med flest ratings")
print(top_10_rated)

# c) Genomsnittlig rating för top 10 filmer
top_10_titles = top_10_rated.index
top_10_avg_ratings = movie_ratings[movie_ratings["title"].isin(top_10_titles)].groupby("title")["rating"].mean()
print("\n### c) Genomsnittlig rating för top 10 filmer")
print(top_10_avg_ratings)

# d) Plot över årtal och antal filmer
movies["year"] = movies["title"].str.extract(r"\((\d{4})\)")  # Extrahera årtal från titel
year_counts = movies["year"].value_counts().sort_index()
plt.figure(figsize=(12, 6))
plt.plot(year_counts.index, year_counts.values, color="teal")
plt.title("Antal filmer per årtal", fontsize=14)
plt.xlabel("Årtal", fontsize=12)
plt.ylabel("Antal filmer", fontsize=12)
plt.xticks(rotation=45)
plt.savefig(os.path.join(output_dir, "movies_per_year.png"), facecolor="white", bbox_inches="tight")
plt.close()

# e) Plot över antal ratings mot movieId
ratings_per_movie = movie_ratings.groupby("movieId").size()
plt.figure(figsize=(10, 6))
plt.scatter(ratings_per_movie.index, ratings_per_movie.values, alpha=0.5, color="coral")
plt.title("Antal ratings mot MovieId", fontsize=14)
plt.xlabel("MovieId", fontsize=12)
plt.ylabel("Antal ratings", fontsize=12)
plt.savefig(os.path.join(output_dir, "ratings_vs_movieId.png"), facecolor="white", bbox_inches="tight")
plt.close()

# f) Stapeldiagram för genomsnittliga ratings för top 10 filmer
plt.figure(figsize=(10, 6))
sns.barplot(x=top_10_avg_ratings.index, y=top_10_avg_ratings.values, palette="viridis")
plt.title("Genomsnittliga betyg för top 10 filmer med flest ratings", fontsize=14)
plt.xlabel("Film", fontsize=12)
plt.ylabel("Genomsnittligt betyg", fontsize=12)
plt.xticks(rotation=45, ha="right")
plt.savefig(os.path.join(output_dir, "top_10_avg_ratings.png"), facecolor="white", bbox_inches="tight")
plt.close()

# --- 1.2 Skapa gles matris ---

# Kommentar: Att skapa en full pivottabell med alla användare och filmer är minneskrävande.
# Filtrerar till filmer med minst 100 ratings för att minska storleken.
min_ratings = 100
movie_counts = movie_ratings["movieId"].value_counts()
filtered_movies = movie_counts[movie_counts >= min_ratings].index
filtered_ratings = movie_ratings[movie_ratings["movieId"].isin(filtered_movies)]

# Skapa en gles matris direkt utan pivottabell
user_ids = filtered_ratings["userId"].values
movie_ids = filtered_ratings["movieId"].values
ratings_values = filtered_ratings["rating"].values

# Konvertera till index för gles matris
user_idx = pd.factorize(user_ids)[0]
movie_idx = pd.factorize(movie_ids)[0]
sparse_matrix = csc_matrix((ratings_values, (user_idx, movie_idx)), 
                          shape=(len(np.unique(user_ids)), len(np.unique(movie_ids))))

print("\n### 1.2 Gles matris")
print(f"Form på gles matris: {sparse_matrix.shape}")
print(f"Antal icke-nollvärden: {sparse_matrix.nnz}")

# Motivering: Jag filtrerade bort filmer med färre än 100 ratings för att minska minnesanvändning
# och fokusera på populära filmer, vilket gör KNN mer meningsfullt.

# --- 1.3 Recommender system ---

# Skapa KNN-modell baserat på gles matris
knn = NearestNeighbors(metric="cosine", algorithm="brute")
knn.fit(sparse_matrix.T)  # Transponerar så att filmer är rader

# Funktion för att hämta rekommendationer baserat på film-titel
def get_recommendations(movie_title, n_recommendations=5):
    if movie_title not in movies["title"].values:
        return f"Film '{movie_title}' hittades inte."
    
    movie_id = movies.loc[movies["title"] == movie_title, "movieId"].values[0]
    if movie_id not in filtered_movies:
        return f"Film '{movie_title}' har för få ratings för rekommendation."
    
    movie_idx = np.where(filtered_movies == movie_id)[0][0]
    distances, indices = knn.kneighbors(sparse_matrix.T[movie_idx].reshape(1, -1), 
                                        n_neighbors=n_recommendations+1)
    
    recommended_movie_ids = filtered_movies[indices.flatten()[1:]]  # Hoppa över första (själva filmen)
    recommended_titles = movies[movies["movieId"].isin(recommended_movie_ids)]["title"].values
    return recommended_titles

# Användarinput och rekommendationer
print("\n### 1.3 Recommender system")
while True:
    query = input("Ange en filmtitel (eller 'avsluta' för att sluta): ").strip()
    if query.lower() == "avsluta":
        break
    recommendations = get_recommendations(query)
    if isinstance(recommendations, str):
        print(recommendations)
    else:
        print(f"Top 5 rekommendationer för '{query}':")
        for i, title in enumerate(recommendations, 1):
            print(f"{i}. {title}")

# a) Beskrivning av systemet
print("\n### a) Hur systemet fungerar")
print("Systemet använder KNN för att hitta liknande filmer baserat på användarbetyg. En gles matris skapas från "
      "filtrerade ratings (filmer med minst 100 ratings). KNN beräknar cosinusavstånd mellan filmer baserat på "
      "betygsvektorer. Användaren anger en filmtitel, och systemet returnerar de 5 närmaste filmerna.")

# b) Kort om rekommendationssystem
print("\n### b) Om rekommendationssystem")
print("Rekommendationssystem predictar användarpreferenser baserat på historisk data. Det finns två hovedtyper: "
      "1) Content-based (använder filmattribut som genre), 2) Collaborative filtering (använder användarbeteenden, "
      "som i detta fall med KNN). Källa: 'Recommender Systems Handbook' (Ricci et al., 2011).")

# Kommentar: Felet i videon är ofta att man inte filtrerar data, vilket gör KNN ineffektiv på stora dataset.
# Jag åtgärdade detta genom att filtrera och använda gles matris.